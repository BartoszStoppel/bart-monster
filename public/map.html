<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monster Town - Map</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
    }
    h1 {
      color: #e0e0ff;
      font-size: 1.8rem;
      margin-bottom: 16px;
      text-shadow: 0 0 20px rgba(131, 56, 236, 0.5);
      letter-spacing: 3px;
    }
    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .label {
      color: #8888aa;
      font-size: 0.8rem;
      margin-top: 12px;
      letter-spacing: 1px;
    }
  </style>
</head>
<body>
  <h1>MONSTER TOWN</h1>
  <canvas id="mapCanvas"></canvas>
  <p class="label">~ a cozy little town ~</p>

  <script>
    const TILE = 32;
    const SCALE = 2;
    const MW = 24;
    const MH = 18;
    const VW = MW + 1;
    const VH = MH + 1;

    // Terrain types
    const GRASS = 0, PATH = 1, DIRT = 2, WATER = 3;

    // Vertex terrain grid — default all grass
    const terrain = Array.from({ length: VH }, () => Array(VW).fill(GRASS));

    function fill(t, x1, y1, x2, y2) {
      for (let y = Math.max(0, y1); y <= Math.min(VH - 1, y2); y++)
        for (let x = Math.max(0, x1); x <= Math.min(VW - 1, x2); x++)
          terrain[y][x] = t;
    }

    // ── Town Layout ──────────────────────────────────
    // Order matters: later fills overwrite earlier ones.

    // 1. Path network (roads)
    fill(PATH, 11, 0, 13, 18);     // main vertical road
    fill(PATH, 0, 8, 24, 10);      // main horizontal road
    fill(PATH, 9, 6, 15, 12);      // central plaza
    fill(PATH, 6, 6, 9, 8);        // upper-left connector
    fill(PATH, 15, 6, 18, 8);      // upper-right connector
    fill(PATH, 6, 10, 9, 12);      // lower-left connector
    fill(PATH, 15, 10, 18, 12);    // lower-right connector

    // 2. Dirt building pads (overwrite path where they sit)
    fill(DIRT, 2, 2, 6, 5);        // B1 — top far-left
    fill(DIRT, 18, 2, 22, 5);      // B2 — top far-right
    fill(DIRT, 7, 2, 10, 5);       // B3 — top near-left
    fill(DIRT, 14, 2, 17, 5);      // B4 — top near-right
    fill(DIRT, 2, 13, 6, 16);      // B5 — bottom far-left
    fill(DIRT, 18, 13, 22, 16);    // B6 — bottom far-right
    fill(DIRT, 7, 13, 10, 16);     // B7 — bottom near-left
    fill(DIRT, 14, 13, 17, 16);    // B8 — bottom near-right

    // 3. Water features
    fill(WATER, 0, 16, 2, 18);     // bottom-left pond
    fill(WATER, 22, 0, 24, 2);     // top-right pond

    // ── Tileset config ───────────────────────────────
    const TILESET_FOR = {
      [PATH]:  'grass_path',
      [DIRT]:  'grass_dirt',
      [WATER]: 'grass_water',
    };

    const tilesets = {};   // name → { img, index }
    const accentImgs = {};

    function loadImg(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    async function loadTileset(name) {
      const base = `sprites/map/tileset/${name}`;
      const [img, meta] = await Promise.all([
        loadImg(`${base}/${name}.png`),
        fetch(`${base}/${name}_metadata.json`).then(r => r.json()),
      ]);
      const index = {};
      for (const tile of meta.tileset_data.tiles) {
        const key = [
          tile.corners.NW, tile.corners.NE,
          tile.corners.SW, tile.corners.SE,
        ].join(',');
        index[key] = tile.bounding_box;
      }
      return { img, index };
    }

    async function loadAssets() {
      const names = ['grass_path', 'grass_dirt', 'grass_water'];
      const results = await Promise.all(names.map(loadTileset));
      names.forEach((n, i) => tilesets[n] = results[i]);

      accentImgs.flowers    = await loadImg('sprites/map/accents/flowers.png');
      accentImgs.dark_grass = await loadImg('sprites/map/accents/dark_grass.png');
    }

    // For a given cell, decide which tileset + corner mapping to use.
    function cellInfo(tx, ty) {
      const c = [
        terrain[ty][tx],        // NW
        terrain[ty][tx + 1],    // NE
        terrain[ty + 1][tx],    // SW
        terrain[ty + 1][tx + 1] // SE
      ];

      // Find non-grass terrains present
      const counts = {};
      for (const v of c) {
        if (v !== GRASS) counts[v] = (counts[v] || 0) + 1;
      }
      const types = Object.keys(counts).map(Number);

      if (types.length === 0) {
        // All grass — use any tileset's "all upper" tile
        return { ts: 'grass_path', corners: ['upper','upper','upper','upper'] };
      }

      // Pick the non-grass terrain with most corners; tiebreak by priority
      let primary = types[0];
      for (const t of types) {
        if (counts[t] > counts[primary] ||
            (counts[t] === counts[primary] && t > primary)) {
          primary = t;
        }
      }

      const tsName = TILESET_FOR[primary];
      // grass → upper, everything else → lower
      const mapped = c.map(v => v === GRASS ? 'upper' : 'lower');
      return { ts: tsName, corners: mapped };
    }

    // Seeded random for reproducible accent placement
    function makeRng(seed) {
      return () => { seed = (seed * 16807) % 2147483647; return seed / 2147483647; };
    }

    async function render() {
      await loadAssets();

      const canvas = document.getElementById('mapCanvas');
      const W = MW * TILE;
      const H = MH * TILE;
      canvas.width  = W * SCALE;
      canvas.height = H * SCALE;
      canvas.style.width  = canvas.width  + 'px';
      canvas.style.height = canvas.height + 'px';

      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.scale(SCALE, SCALE);

      // ── Draw tiles ──
      for (let ty = 0; ty < MH; ty++) {
        for (let tx = 0; tx < MW; tx++) {
          const { ts, corners } = cellInfo(tx, ty);
          const tileset = tilesets[ts];
          const key = corners.join(',');
          const bbox = tileset.index[key];
          if (bbox) {
            ctx.drawImage(
              tileset.img,
              bbox.x, bbox.y, bbox.width, bbox.height,
              tx * TILE, ty * TILE, TILE, TILE,
            );
          }
        }
      }

      // ── Accent decorations on pure-grass tiles ──
      const rng = makeRng(42);
      for (let ty = 0; ty < MH; ty++) {
        for (let tx = 0; tx < MW; tx++) {
          const nw = terrain[ty][tx], ne = terrain[ty][tx+1];
          const sw = terrain[ty+1][tx], se = terrain[ty+1][tx+1];
          if (nw !== GRASS || ne !== GRASS || sw !== GRASS || se !== GRASS) {
            rng(); // consume so positions stay stable
            continue;
          }
          const r = rng();
          if (r < 0.05) {
            ctx.drawImage(accentImgs.flowers, tx * TILE, ty * TILE, TILE, TILE);
          } else if (r < 0.12) {
            ctx.globalAlpha = 0.5;
            ctx.drawImage(accentImgs.dark_grass, tx * TILE, ty * TILE, TILE, TILE);
            ctx.globalAlpha = 1;
          }
        }
      }

      // ── Building spot overlays ──
      const spots = [
        { x: 2,  y: 2,  w: 4, h: 3, label: '1' },
        { x: 18, y: 2,  w: 4, h: 3, label: '2' },
        { x: 7,  y: 2,  w: 3, h: 3, label: '3' },
        { x: 14, y: 2,  w: 3, h: 3, label: '4' },
        { x: 2,  y: 13, w: 4, h: 3, label: '5' },
        { x: 18, y: 13, w: 4, h: 3, label: '6' },
        { x: 7,  y: 13, w: 3, h: 3, label: '7' },
        { x: 14, y: 13, w: 3, h: 3, label: '8' },
      ];

      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#ffbe0b';
      for (const s of spots) {
        ctx.fillRect(s.x * TILE, s.y * TILE, s.w * TILE, s.h * TILE);
      }
      ctx.globalAlpha = 1;

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const s of spots) {
        ctx.fillText(
          `B${s.label}`,
          (s.x + s.w / 2) * TILE,
          (s.y + s.h / 2) * TILE,
        );
      }

      // Plaza label
      ctx.fillStyle = '#e0e0ff';
      ctx.font = 'bold 12px Courier New';
      ctx.fillText('PLAZA', 12 * TILE, 9 * TILE);
    }

    render();
  </script>
</body>
</html>
