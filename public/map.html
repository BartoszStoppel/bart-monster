<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monster Town - Map</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Courier New', monospace;
      padding: 20px 0;
    }
    h1 {
      color: #e0e0ff;
      font-size: 1.8rem;
      margin-bottom: 16px;
      text-shadow: 0 0 20px rgba(131, 56, 236, 0.5);
      letter-spacing: 3px;
    }
    .map-scroll {
      overflow: auto;
      max-width: 95vw;
      max-height: 85vh;
      border: 2px solid #333;
      border-radius: 8px;
    }
    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display: block;
    }
    .label {
      color: #8888aa;
      font-size: 0.8rem;
      margin-top: 12px;
      letter-spacing: 1px;
    }
  </style>
</head>
<body>
  <h1>MONSTER TOWN</h1>
  <div class="map-scroll">
    <canvas id="mapCanvas"></canvas>
  </div>
  <p class="label">~ a cozy little town ~</p>

  <script>
    const TILE = 32;
    const SCALE = 2;
    const MW = 40;
    const MH = 30;
    const VW = MW + 1;
    const VH = MH + 1;

    const GRASS = 1, PATH = 0;

    const terrain = Array.from({ length: VH }, () => Array(VW).fill(GRASS));

    function fill(t, x1, y1, x2, y2) {
      for (let y = Math.max(0, y1); y <= Math.min(VH - 1, y2); y++)
        for (let x = Math.max(0, x1); x <= Math.min(VW - 1, x2); x++)
          terrain[y][x] = t;
    }

    // ── Town Layout ──

    // Main vertical road
    fill(PATH, 19, 4, 21, 26);
    // Main horizontal road
    fill(PATH, 4, 14, 36, 16);
    // Central plaza
    fill(PATH, 16, 12, 24, 18);

    // 8 building pads — top row
    fill(PATH, 8,  8, 12, 11);
    fill(PATH, 14, 8, 18, 11);
    fill(PATH, 22, 8, 26, 11);
    fill(PATH, 28, 8, 32, 11);
    // Bottom row
    fill(PATH, 8,  19, 12, 22);
    fill(PATH, 14, 19, 18, 22);
    fill(PATH, 22, 19, 26, 22);
    fill(PATH, 28, 19, 32, 22);

    // Connectors to main roads
    fill(PATH, 10, 12, 11, 13);
    fill(PATH, 16, 12, 17, 13);
    fill(PATH, 24, 12, 25, 13);
    fill(PATH, 30, 12, 31, 13);
    fill(PATH, 10, 17, 11, 18);
    fill(PATH, 16, 17, 17, 18);
    fill(PATH, 24, 17, 25, 18);
    fill(PATH, 30, 17, 31, 18);

    // Entry roads
    fill(PATH, 19, 2, 21, 4);
    fill(PATH, 19, 26, 21, 28);
    fill(PATH, 2, 14, 4, 16);
    fill(PATH, 36, 14, 38, 16);

    // ── Rendering ──

    let tileset = null;
    const accentImgs = {};

    function loadImg(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    async function loadAssets() {
      const [img, meta] = await Promise.all([
        loadImg('sprites/map/tileset/grass_path/grass_path.png'),
        fetch('sprites/map/tileset/grass_path/grass_path_metadata.json').then(r => r.json()),
      ]);
      const index = {};
      for (const tile of meta.tileset_data.tiles) {
        const key = [
          tile.corners.NW, tile.corners.NE,
          tile.corners.SW, tile.corners.SE,
        ].join(',');
        index[key] = tile.bounding_box;
      }
      tileset = { img, index };

      const names = ['flowers','dark_grass','mushrooms','bush','rocks','barrel','signpost','bench','well','crate'];
      const results = await Promise.all(names.map(n => loadImg(`sprites/map/accents/${n}.png`)));
      names.forEach((n, i) => accentImgs[n] = results[i]);
    }

    function makeRng(seed) {
      return () => { seed = (seed * 16807 + 12345) % 2147483647; return (seed & 0x7fffffff) / 2147483647; };
    }

    async function render() {
      await loadAssets();

      const canvas = document.getElementById('mapCanvas');
      canvas.width  = MW * TILE * SCALE;
      canvas.height = MH * TILE * SCALE;
      canvas.style.width  = canvas.width + 'px';
      canvas.style.height = canvas.height + 'px';

      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.scale(SCALE, SCALE);

      // Draw tiles
      for (let ty = 0; ty < MH; ty++) {
        for (let tx = 0; tx < MW; tx++) {
          const c = [
            terrain[ty][tx], terrain[ty][tx+1],
            terrain[ty+1][tx], terrain[ty+1][tx+1],
          ];
          const key = c.map(v => v === GRASS ? 'upper' : 'lower').join(',');
          const bbox = tileset.index[key];
          if (bbox) {
            ctx.drawImage(tileset.img, bbox.x, bbox.y, bbox.width, bbox.height,
              tx * TILE, ty * TILE, TILE, TILE);
          }
        }
      }

      // Decorations (max 2 per type)
      const decoRng = makeRng(42);
      const counts = {};

      function place(tx, ty, name, opacity) {
        if ((counts[name] || 0) >= 2) return;
        counts[name] = (counts[name] || 0) + 1;
        ctx.globalAlpha = opacity;
        ctx.drawImage(accentImgs[name], tx * TILE, ty * TILE, TILE, TILE);
        ctx.globalAlpha = 1;
      }

      for (let ty = 0; ty < MH; ty++) {
        for (let tx = 0; tx < MW; tx++) {
          const c = [terrain[ty][tx], terrain[ty][tx+1], terrain[ty+1][tx], terrain[ty+1][tx+1]];
          if (!c.every(v => v === c[0])) { decoRng(); continue; }
          const r = decoRng();
          if (c[0] === GRASS) {
            if      (r < 0.008) place(tx, ty, 'flowers', 1);
            else if (r < 0.016) place(tx, ty, 'dark_grass', 0.5);
            else if (r < 0.022) place(tx, ty, 'mushrooms', 1);
            else if (r < 0.028) place(tx, ty, 'bush', 1);
          } else if (c[0] === PATH) {
            if      (r < 0.008) place(tx, ty, 'rocks', 0.8);
            else if (r < 0.016) place(tx, ty, 'crate', 1);
            else if (r < 0.022) place(tx, ty, 'barrel', 1);
          }
        }
      }

      place(18, 7, 'signpost', 1);
      place(22, 23, 'signpost', 1);
      place(18, 14, 'bench', 1);
      place(22, 16, 'bench', 1);
      place(20, 15, 'well', 1);

      // Building labels
      const spots = [
        { x: 8,  y: 8,  w: 4, h: 3, label: '1' },
        { x: 14, y: 8,  w: 4, h: 3, label: '2' },
        { x: 22, y: 8,  w: 4, h: 3, label: '3' },
        { x: 28, y: 8,  w: 4, h: 3, label: '4' },
        { x: 8,  y: 19, w: 4, h: 3, label: '5' },
        { x: 14, y: 19, w: 4, h: 3, label: '6' },
        { x: 22, y: 19, w: 4, h: 3, label: '7' },
        { x: 28, y: 19, w: 4, h: 3, label: '8' },
      ];

      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#ffbe0b';
      for (const s of spots)
        ctx.fillRect(s.x * TILE, s.y * TILE, s.w * TILE, s.h * TILE);
      ctx.globalAlpha = 1;

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const s of spots)
        ctx.fillText(`B${s.label}`, (s.x + s.w / 2) * TILE, (s.y + s.h / 2) * TILE);

      ctx.fillStyle = '#e0e0ff';
      ctx.fillText('TOWN PLAZA', 20.5 * TILE, 15 * TILE);
    }

    render();
  </script>
</body>
</html>
