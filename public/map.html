<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monster Town - Map</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Courier New', monospace;
      padding: 20px 0;
    }
    h1 {
      color: #e0e0ff;
      font-size: 1.8rem;
      margin-bottom: 16px;
      text-shadow: 0 0 20px rgba(131, 56, 236, 0.5);
      letter-spacing: 3px;
    }
    .map-scroll {
      overflow: auto;
      max-width: 95vw;
      max-height: 85vh;
      border: 2px solid #333;
      border-radius: 8px;
    }
    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display: block;
    }
    .label {
      color: #8888aa;
      font-size: 0.8rem;
      margin-top: 12px;
      letter-spacing: 1px;
    }
  </style>
</head>
<body>
  <h1>MONSTER TOWN</h1>
  <div class="map-scroll">
    <canvas id="mapCanvas"></canvas>
  </div>
  <p class="label">~ a cozy little town ~</p>

  <script>
    const TILE = 32;
    const SCALE = 2;
    const MW = 40;   // map tiles wide
    const MH = 30;   // map tiles tall
    const VW = MW + 1;
    const VH = MH + 1;

    // Terrain types (higher = more elevated)
    const WATER = 0, PATH = 1, DIRT = 2, GRASS = 3, STONE = 4;

    // Vertex terrain grid — default all grass
    const terrain = Array.from({ length: VH }, () => Array(VW).fill(GRASS));

    function fill(t, x1, y1, x2, y2) {
      for (let y = Math.max(0, y1); y <= Math.min(VH - 1, y2); y++)
        for (let x = Math.max(0, x1); x <= Math.min(VW - 1, x2); x++)
          terrain[y][x] = t;
    }

    // ── Town Layout (40x30) ─────────────────────────

    // Stone border around entire map (3 vertices thick)
    fill(STONE, 0, 0, VW - 1, 2);           // top
    fill(STONE, 0, VH - 3, VW - 1, VH - 1); // bottom
    fill(STONE, 0, 0, 2, VH - 1);           // left
    fill(STONE, VW - 3, 0, VW - 1, VH - 1); // right

    // Main vertical road (center)
    fill(PATH, 19, 3, 22, 27);

    // Main horizontal road
    fill(PATH, 3, 13, 37, 16);

    // Central plaza (wider intersection)
    fill(PATH, 16, 11, 25, 18);

    // Connection paths to buildings
    // Upper-left connector
    fill(PATH, 9, 8, 16, 11);
    // Upper-right connector
    fill(PATH, 25, 8, 32, 11);
    // Lower-left connector
    fill(PATH, 9, 18, 16, 21);
    // Lower-right connector
    fill(PATH, 25, 18, 32, 21);

    // Secondary paths to outer buildings
    fill(PATH, 5, 8, 9, 10);    // far left upper
    fill(PATH, 32, 8, 36, 10);  // far right upper
    fill(PATH, 5, 19, 9, 21);   // far left lower
    fill(PATH, 32, 19, 36, 21); // far right lower

    // Entry paths from edges
    fill(PATH, 19, 3, 22, 5);   // north entry
    fill(PATH, 19, 25, 22, 27); // south entry
    fill(PATH, 3, 13, 5, 16);   // west entry
    fill(PATH, 36, 13, 37, 16); // east entry

    // 8 building pads (dirt)
    fill(DIRT, 5, 4, 10, 7);     // B1 — top far-left
    fill(DIRT, 12, 4, 17, 7);    // B2 — top near-left
    fill(DIRT, 24, 4, 29, 7);    // B3 — top near-right
    fill(DIRT, 31, 4, 36, 7);    // B4 — top far-right
    fill(DIRT, 5, 22, 10, 25);   // B5 — bottom far-left
    fill(DIRT, 12, 22, 17, 25);  // B6 — bottom near-left
    fill(DIRT, 24, 22, 29, 25);  // B7 — bottom near-right
    fill(DIRT, 31, 22, 36, 25);  // B8 — bottom far-right

    // Water features
    fill(WATER, 4, 26, 8, 28);   // bottom-left pond
    fill(WATER, 33, 26, 37, 28); // bottom-right pond
    fill(WATER, 35, 4, 37, 6);   // top-right small pond

    // ── Tileset pairs ────────────────────────────────
    // Each tileset handles a transition between two adjacent terrain levels.
    // Within each tileset, "upper" = the higher terrain, "lower" = the lower terrain.
    const PAIRS = [
      { lower: WATER, upper: GRASS, ts: 'grass_water' },  // grass is upper relative to water
      { lower: PATH,  upper: GRASS, ts: 'grass_path' },   // grass is upper relative to path
      { lower: DIRT,  upper: GRASS, ts: 'grass_dirt' },    // grass is upper relative to dirt
      { lower: GRASS, upper: STONE, ts: 'grass_stone' },  // stone is upper relative to grass
    ];

    const tilesets = {};
    const accentImgs = {};

    function loadImg(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    async function loadTileset(name) {
      const base = `sprites/map/tileset/${name}`;
      const [img, meta] = await Promise.all([
        loadImg(`${base}/${name}.png`),
        fetch(`${base}/${name}_metadata.json`).then(r => r.json()),
      ]);
      const index = {};
      for (const tile of meta.tileset_data.tiles) {
        const key = [
          tile.corners.NW, tile.corners.NE,
          tile.corners.SW, tile.corners.SE,
        ].join(',');
        index[key] = tile.bounding_box;
      }
      return { img, index };
    }

    async function loadAssets() {
      const names = ['grass_path', 'grass_dirt', 'grass_water', 'grass_stone'];
      const results = await Promise.all(names.map(loadTileset));
      names.forEach((n, i) => tilesets[n] = results[i]);

      const accentNames = [
        'flowers', 'dark_grass', 'mushrooms', 'bush', 'rocks',
        'barrel', 'signpost', 'bench', 'well', 'crate',
      ];
      const accentResults = await Promise.all(
        accentNames.map(n => loadImg(`sprites/map/accents/${n}.png`))
      );
      accentNames.forEach((n, i) => accentImgs[n] = accentResults[i]);
    }

    // For each cell, determine which tileset + corner mapping to use.
    function cellInfo(tx, ty) {
      const c = [
        terrain[ty][tx],        // NW
        terrain[ty][tx + 1],    // NE
        terrain[ty + 1][tx],    // SW
        terrain[ty + 1][tx + 1] // SE
      ];

      // Find the unique terrain values present
      const unique = [...new Set(c)];

      if (unique.length === 1) {
        // All same terrain — find a pair where this terrain is either upper or lower
        const t = unique[0];
        for (const p of PAIRS) {
          if (t === p.upper) return { ts: p.ts, corners: ['upper','upper','upper','upper'] };
          if (t === p.lower) return { ts: p.ts, corners: ['lower','lower','lower','lower'] };
        }
        // Fallback: all grass
        return { ts: 'grass_path', corners: ['upper','upper','upper','upper'] };
      }

      // Find the best-matching pair for the terrains present
      // Try to find a pair that directly covers both terrain values
      for (const p of PAIRS) {
        const hasUpper = c.some(v => v === p.upper);
        const hasLower = c.some(v => v === p.lower);
        if (hasUpper && hasLower) {
          // Check if ALL corners are either upper or lower for this pair
          const allMatch = c.every(v => v === p.upper || v === p.lower);
          if (allMatch) {
            const mapped = c.map(v => v === p.upper ? 'upper' : 'lower');
            return { ts: p.ts, corners: mapped };
          }
        }
      }

      // Mixed case: pick the pair that covers the most corners
      let bestPair = PAIRS[0], bestScore = 0;
      for (const p of PAIRS) {
        const score = c.filter(v => v === p.upper || v === p.lower).length;
        if (score > bestScore) { bestScore = score; bestPair = p; }
      }
      const mapped = c.map(v => {
        if (v === bestPair.upper) return 'upper';
        if (v === bestPair.lower) return 'lower';
        // For unmatched terrain, map to whichever is closer in elevation
        return v > bestPair.upper ? 'upper' : v < bestPair.lower ? 'lower' :
               Math.abs(v - bestPair.upper) <= Math.abs(v - bestPair.lower) ? 'upper' : 'lower';
      });
      return { ts: bestPair.ts, corners: mapped };
    }

    // Seeded RNG for reproducible randomness
    function makeRng(seed) {
      return () => { seed = (seed * 16807 + 12345) % 2147483647; return (seed & 0x7fffffff) / 2147483647; };
    }

    // Build decoration placement map
    function buildDecorations(rng) {
      const decos = [];

      for (let ty = 0; ty < MH; ty++) {
        for (let tx = 0; tx < MW; tx++) {
          const c = [terrain[ty][tx], terrain[ty][tx+1], terrain[ty+1][tx], terrain[ty+1][tx+1]];
          const allSame = c.every(v => v === c[0]);
          const r = rng();

          if (allSame && c[0] === GRASS) {
            // Grass decorations — varied
            if (r < 0.04)      decos.push({ tx, ty, img: 'flowers', opacity: 1 });
            else if (r < 0.08) decos.push({ tx, ty, img: 'dark_grass', opacity: 0.5 });
            else if (r < 0.10) decos.push({ tx, ty, img: 'mushrooms', opacity: 1 });
            else if (r < 0.13) decos.push({ tx, ty, img: 'bush', opacity: 1 });
          } else if (allSame && c[0] === DIRT) {
            // Dirt decorations
            if (r < 0.06)      decos.push({ tx, ty, img: 'rocks', opacity: 0.8 });
            else if (r < 0.09) decos.push({ tx, ty, img: 'crate', opacity: 1 });
          } else if (allSame && c[0] === PATH) {
            // Path decorations — sparse
            if (r < 0.015)     decos.push({ tx, ty, img: 'barrel', opacity: 1 });
          }
        }
      }

      return decos;
    }

    // Fixed decoration placements (signposts, benches, well — placed at specific locations)
    function fixedDecorations() {
      return [
        // Signposts at road junctions
        { tx: 18, ty: 5, img: 'signpost', opacity: 1 },
        { tx: 22, ty: 25, img: 'signpost', opacity: 1 },
        { tx: 4, ty: 13, img: 'signpost', opacity: 1 },
        { tx: 36, ty: 15, img: 'signpost', opacity: 1 },
        // Benches around the plaza
        { tx: 17, ty: 12, img: 'bench', opacity: 1 },
        { tx: 24, ty: 12, img: 'bench', opacity: 1 },
        { tx: 17, ty: 17, img: 'bench', opacity: 1 },
        { tx: 24, ty: 17, img: 'bench', opacity: 1 },
        // Well near the plaza
        { tx: 20, ty: 14, img: 'well', opacity: 1 },
        // Barrels near buildings
        { tx: 10, ty: 7, img: 'barrel', opacity: 1 },
        { tx: 31, ty: 7, img: 'barrel', opacity: 1 },
        { tx: 10, ty: 22, img: 'barrel', opacity: 1 },
        { tx: 31, ty: 22, img: 'barrel', opacity: 1 },
      ];
    }

    async function render() {
      await loadAssets();

      const canvas = document.getElementById('mapCanvas');
      const W = MW * TILE;
      const H = MH * TILE;
      canvas.width  = W * SCALE;
      canvas.height = H * SCALE;
      canvas.style.width  = canvas.width  + 'px';
      canvas.style.height = canvas.height + 'px';

      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.scale(SCALE, SCALE);

      const rng = makeRng(1337);

      // ── Draw base tiles ──
      for (let ty = 0; ty < MH; ty++) {
        for (let tx = 0; tx < MW; tx++) {
          const { ts, corners } = cellInfo(tx, ty);
          const tileset = tilesets[ts];
          const key = corners.join(',');
          const bbox = tileset.index[key];
          if (bbox) {
            // Add tile variation: random flip for uniform tiles
            const allSame = corners.every(c => c === corners[0]);
            const flip = allSame ? rng() : -1;

            ctx.save();
            const dx = tx * TILE;
            const dy = ty * TILE;

            if (flip > 0.75) {
              // Flip horizontal
              ctx.translate(dx + TILE, dy);
              ctx.scale(-1, 1);
              ctx.drawImage(tileset.img, bbox.x, bbox.y, bbox.width, bbox.height, 0, 0, TILE, TILE);
            } else if (flip > 0.5) {
              // Flip vertical
              ctx.translate(dx, dy + TILE);
              ctx.scale(1, -1);
              ctx.drawImage(tileset.img, bbox.x, bbox.y, bbox.width, bbox.height, 0, 0, TILE, TILE);
            } else if (flip > 0.25) {
              // Flip both
              ctx.translate(dx + TILE, dy + TILE);
              ctx.scale(-1, -1);
              ctx.drawImage(tileset.img, bbox.x, bbox.y, bbox.width, bbox.height, 0, 0, TILE, TILE);
            } else {
              // No flip
              ctx.drawImage(tileset.img, bbox.x, bbox.y, bbox.width, bbox.height, dx, dy, TILE, TILE);
            }
            ctx.restore();
          }
        }
      }

      // ── Draw random decorations ──
      const decos = buildDecorations(makeRng(42));
      for (const d of decos) {
        const img = accentImgs[d.img];
        if (img) {
          ctx.globalAlpha = d.opacity;
          ctx.drawImage(img, d.tx * TILE, d.ty * TILE, TILE, TILE);
        }
      }
      ctx.globalAlpha = 1;

      // ── Draw fixed decorations ──
      for (const d of fixedDecorations()) {
        const img = accentImgs[d.img];
        if (img) {
          ctx.globalAlpha = d.opacity;
          ctx.drawImage(img, d.tx * TILE, d.ty * TILE, TILE, TILE);
        }
      }
      ctx.globalAlpha = 1;

      // ── Building spot overlays ──
      const spots = [
        { x: 5,  y: 4,  w: 5, h: 3, label: '1' },
        { x: 12, y: 4,  w: 5, h: 3, label: '2' },
        { x: 24, y: 4,  w: 5, h: 3, label: '3' },
        { x: 31, y: 4,  w: 5, h: 3, label: '4' },
        { x: 5,  y: 22, w: 5, h: 3, label: '5' },
        { x: 12, y: 22, w: 5, h: 3, label: '6' },
        { x: 24, y: 22, w: 5, h: 3, label: '7' },
        { x: 31, y: 22, w: 5, h: 3, label: '8' },
      ];

      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#ffbe0b';
      for (const s of spots) {
        ctx.fillRect(s.x * TILE, s.y * TILE, s.w * TILE, s.h * TILE);
      }
      ctx.globalAlpha = 1;

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const s of spots) {
        ctx.fillText(`B${s.label}`, (s.x + s.w / 2) * TILE, (s.y + s.h / 2) * TILE);
      }

      // Plaza label
      ctx.fillStyle = '#e0e0ff';
      ctx.font = 'bold 14px Courier New';
      ctx.fillText('TOWN PLAZA', 20.5 * TILE, 14.5 * TILE);
    }

    render();
  </script>
</body>
</html>
